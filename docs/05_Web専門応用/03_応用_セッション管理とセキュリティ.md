# é«˜åº¦ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†æŠ€è¡“

## ã¯ã˜ã‚ã«

ç¾ä»£ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ã€**ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**ã¯æœ€ã‚‚é‡è¦ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã®ä¸€ã¤ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªè¨¼çŠ¶æ…‹ã€ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆã€ä¸€æ™‚çš„ãªãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹ç‡çš„ã‹ã¤å®‰å…¨ã«ç®¡ç†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å®Ÿè£…æ–¹å¼ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«ç›´çµã—ã¾ã™ã€‚ä¸é©åˆ‡ãªè¨­è¨ˆã¯ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã¨ãªã‚Šã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®åŸå› ã«ã‚‚ãªã‚Šã¾ã™ã€‚

ã“ã®ç« ã§ã¯ã€**ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³**ã¨**Cookieãƒ™ãƒ¼ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³**ã®æŠ€è¡“çš„è©³ç´°ã€å„ç¨®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ–¹å¼ã®ç‰¹æ€§ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­è¨ˆã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å­¦ã³ã¾ã™ã€‚

## ğŸ“Š ã“ã®ç« ã®é‡è¦åº¦ï¼šğŸ”´ å¿œç”¨ï¼ˆå°‚é–€æŠ€è¡“ï¼‰

**ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆã«ã¨ã£ã¦ï¼š**
- ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã—ãŸã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­è¨ˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãƒãƒ©ãƒ³ã‚¹
- åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã§ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†æˆ¦ç•¥

## ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†æ–¹å¼ã®æŠ€è¡“çš„æ¯”è¼ƒ

**ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ™‚ã®åˆ¤æ–­å¤‰åŒ–ï¼š**
- å¾“æ¥ï¼šã€Œãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ã€
- é«˜åº¦ï¼šã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã€ãƒ‡ãƒ¼ã‚¿é‡ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã€ã‚¤ãƒ³ãƒ•ãƒ©ã‚³ã‚¹ãƒˆã‚’ç·åˆçš„ã«è©•ä¾¡ã—ã€æœ€é©ãªã‚»ãƒƒã‚·ãƒ§ãƒ³æˆ¦ç•¥ã‚’é¸æŠã€

## ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ vs. Cookieãƒ™ãƒ¼ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³

### åŸºæœ¬çš„ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®é•ã„

```mermaid
flowchart TD
    subgraph "ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³"
        A1["ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"] --> B1["ã‚»ãƒƒã‚·ãƒ§ãƒ³ID<br/>(Cookie)"]
        B1 --> C1["Webã‚µãƒ¼ãƒãƒ¼"]
        C1 --> D1["ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸<br/>(Redis/DB/Memory)"]
        D1 --> E1["ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿<br/>{user_id, cart, preferences}"]
    end
    
    subgraph "Cookieãƒ™ãƒ¼ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³"
        A2["ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"] --> B2["ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿<br/>(æš—å·åŒ–Cookie)"]
        B2 --> C2["Webã‚µãƒ¼ãƒãƒ¼"]
        C2 --> D2["å¾©å·åŒ–ãƒ»æ¤œè¨¼"]
        D2 --> E2["ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿<br/>{user_id, cart, preferences}"]
    end
```

### ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è©³ç´°å®Ÿè£…

**ç‰¹å¾´ï¼š**
- Cookieã«ã¯æœ€å°é™ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆé€šå¸¸128-256bitï¼‰ã®ã¿ä¿å­˜
- å®Ÿéš›ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¯ã‚µãƒ¼ãƒãƒ¼å´ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
- **ã‚¹ãƒ†ãƒ¼ãƒˆãƒ•ãƒ«**ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

**å®Ÿè£…ä¾‹ï¼ˆFlask + Redisï¼‰ï¼š**
```python
import redis
import uuid
import json
from datetime import datetime, timedelta

class ServerSideSessionManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.session_prefix = "session:"
        self.default_ttl = 3600  # 1æ™‚é–“
    
    def create_session(self, user_id, data=None):
        """æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ"""
        session_id = str(uuid.uuid4())  # æš—å·è«–çš„ã«å®‰å…¨ãªID
        session_data = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'last_accessed': datetime.utcnow().isoformat(),
            'data': data or {}
        }
        
        # Redisã«ä¿å­˜ï¼ˆTTLä»˜ãï¼‰
        self.redis.setex(
            f"{self.session_prefix}{session_id}",
            self.default_ttl,
            json.dumps(session_data)
        )
        
        return session_id
    
    def get_session(self, session_id):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—ã¨æœ€çµ‚ã‚¢ã‚¯ã‚»ã‚¹æ™‚åˆ»æ›´æ–°"""
        session_data = self.redis.get(f"{self.session_prefix}{session_id}")
        
        if session_data:
            data = json.loads(session_data)
            # æœ€çµ‚ã‚¢ã‚¯ã‚»ã‚¹æ™‚åˆ»ã‚’æ›´æ–°
            data['last_accessed'] = datetime.utcnow().isoformat()
            
            # TTLã‚’å»¶é•·ï¼ˆã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰
            self.redis.setex(
                f"{self.session_prefix}{session_id}",
                self.default_ttl,
                json.dumps(data)
            )
            
            return data
        
        return None
    
    def update_session(self, session_id, update_data):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿æ›´æ–°"""
        session_data = self.get_session(session_id)
        if session_data:
            session_data['data'].update(update_data)
            session_data['last_accessed'] = datetime.utcnow().isoformat()
            
            self.redis.setex(
                f"{self.session_prefix}{session_id}",
                self.default_ttl,
                json.dumps(session_data)
            )
            
            return True
        return False
    
    def destroy_session(self, session_id):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤"""
        return self.redis.delete(f"{self.session_prefix}{session_id}")
```

**ãƒ¡ãƒªãƒƒãƒˆï¼š**
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒé«˜ã„**ï¼šæ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«å­˜åœ¨ã—ãªã„
- **ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºåˆ¶é™ãªã—**ï¼šCookieã®4KBåˆ¶é™ã«å½±éŸ¿ã•ã‚Œãªã„
- **ã‚µãƒ¼ãƒãƒ¼å´ã§å®Œå…¨åˆ¶å¾¡**ï¼šå¼·åˆ¶ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ç„¡åŠ¹åŒ–ãŒå¯èƒ½
- **ç›£æŸ»ãƒ­ã‚°å¯¾å¿œ**ï¼šã‚¢ã‚¯ã‚»ã‚¹å±¥æ­´ã®è©³ç´°è¨˜éŒ²ãŒå¯èƒ½

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆï¼š**
- **ã‚µãƒ¼ãƒãƒ¼è² è·**ï¼šã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ç®¡ç†ã‚³ã‚¹ãƒˆãŒç™ºç”Ÿ
- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã®èª²é¡Œ**ï¼šè¤‡æ•°ã‚µãƒ¼ãƒãƒ¼é–“ã§ã®çŠ¶æ…‹å…±æœ‰ãŒå¿…è¦
- **ã‚¤ãƒ³ãƒ•ãƒ©è¤‡é›‘æ€§**ï¼šRedisç­‰ã®å¤–éƒ¨ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒå¿…è¦

### Cookieãƒ™ãƒ¼ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®è©³ç´°å®Ÿè£…

**ç‰¹å¾´ï¼š**
- ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿è‡ªä½“ã‚’æš—å·åŒ–ã—ã¦Cookieã«ä¿å­˜
- ã‚µãƒ¼ãƒãƒ¼ã¯**ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹**ï¼šã‚»ãƒƒã‚·ãƒ§ãƒ³ç”¨ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒä¸è¦
- JWTã‚„ItsDangerousãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨

**å®Ÿè£…ä¾‹ï¼ˆFlask + ItsDangerousï¼‰ï¼š**
```python
from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired
import json
from datetime import datetime, timedelta

class CookieBasedSessionManager:
    def __init__(self, secret_key, salt='session'):
        self.serializer = URLSafeTimedSerializer(secret_key)
        self.salt = salt
        self.max_age = 3600  # 1æ™‚é–“
    
    def create_session_token(self, user_id, data=None):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ãƒˆãƒ¼ã‚¯ãƒ³åŒ–"""
        session_data = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'data': data or {}
        }
        
        # ãƒ‡ãƒ¼ã‚¿ã‚’ç½²åä»˜ããƒˆãƒ¼ã‚¯ãƒ³ã«å¤‰æ›
        token = self.serializer.dumps(session_data, salt=self.salt)
        return token
    
    def validate_session_token(self, token):
        """ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼ã¨ãƒ‡ãƒ¼ã‚¿å–å¾—"""
        try:
            # ç½²åã¨æœ‰åŠ¹æœŸé™ã‚’æ¤œè¨¼
            session_data = self.serializer.loads(
                token,
                salt=self.salt,
                max_age=self.max_age
            )
            return session_data
            
        except SignatureExpired:
            # ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™åˆ‡ã‚Œ
            return None
            
        except BadSignature:
            # ä¸æ­£ãªãƒˆãƒ¼ã‚¯ãƒ³
            return None
    
    def update_session_token(self, token, update_data):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿æ›´æ–°ï¼ˆæ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼‰"""
        session_data = self.validate_session_token(token)
        
        if session_data:
            session_data['data'].update(update_data)
            # æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆã—ã¦è¿”ã™
            return self.create_session_token(
                session_data['user_id'], 
                session_data['data']
            )
        
        return None

# Flask ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã®ä½¿ç”¨ä¾‹
@app.route('/login', methods=['POST'])
def login():
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼å‡¦ç†
    if authenticate_user(request.form['username'], request.form['password']):
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
        token = session_manager.create_session_token(
            user.id, 
            {'username': user.username, 'role': user.role}
        )
        
        response = make_response(redirect('/dashboard'))
        response.set_cookie(
            'session_token',
            token,
            httponly=True,
            secure=True,
            samesite='Lax',
            max_age=3600
        )
        return response
```

**ãƒ¡ãƒªãƒƒãƒˆï¼š**
- **ã‚µãƒ¼ãƒãƒ¼è² è·è»½æ¸›**ï¼šã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒä¸è¦
- **æ°´å¹³ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**ï¼šè¤‡æ•°ã‚µãƒ¼ãƒãƒ¼é–“ã§çŠ¶æ…‹å…±æœ‰ä¸è¦
- **ã‚¤ãƒ³ãƒ•ãƒ©ç°¡ç´ åŒ–**ï¼šRedisç­‰ã®å¤–éƒ¨ä¾å­˜ãªã—
- **ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œ**ï¼šä¸€æ™‚çš„ãªãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ–­ã§ã‚‚ç¶™ç¶šå¯èƒ½

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆï¼š**
- **ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºåˆ¶é™**ï¼šCookieã®4KBåˆ¶é™
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯**ï¼šæš—å·åŒ–ã‚­ãƒ¼ã®æ¼æ´©ã§ãƒ‡ãƒ¼ã‚¿å¾©å·å¯èƒ½
- **å¼·åˆ¶ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå›°é›£**ï¼šã‚µãƒ¼ãƒãƒ¼å´ã‹ã‚‰ã®å¼·åˆ¶ç„¡åŠ¹åŒ–ãŒå›°é›£
- **ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰**ï¼šãƒ‡ãƒ¼ã‚¿æ›´æ–°æ™‚ã«æ¯å›ãƒˆãƒ¼ã‚¯ãƒ³å†ç”Ÿæˆ

## ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé–“ã¨ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†

### ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé–“ã®æˆ¦ç•¥

ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé–“ã®è¨­è¨ˆã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ã®ãƒãƒ©ãƒ³ã‚¹ãŒé‡è¦ã§ã™ã€‚

**1. çµ¶å¯¾æœŸé™ï¼ˆAbsolute Timeoutï¼‰**
```python
class AbsoluteTimeoutSession:
    def __init__(self, session_lifetime=7200):  # 2æ™‚é–“
        self.session_lifetime = session_lifetime
    
    def create_session(self, user_id):
        expires_at = datetime.utcnow() + timedelta(seconds=self.session_lifetime)
        session_data = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'expires_at': expires_at.isoformat()
        }
        
        # çµ¶å¯¾æœŸé™ã§ã®TTLè¨­å®š
        self.redis.setex(
            f"session:{session_id}",
            self.session_lifetime,  # ä½œæˆæ™‚ç‚¹ã‹ã‚‰å›ºå®šæœŸé–“
            json.dumps(session_data)
        )
```

**2. ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°æœŸé™ï¼ˆSliding Timeoutï¼‰**
```python
class SlidingTimeoutSession:
    def __init__(self, idle_timeout=1800):  # 30åˆ†
        self.idle_timeout = idle_timeout
    
    def access_session(self, session_id):
        session_data = self.redis.get(f"session:{session_id}")
        
        if session_data:
            data = json.loads(session_data)
            data['last_accessed'] = datetime.utcnow().isoformat()
            
            # ã‚¢ã‚¯ã‚»ã‚¹ã®ãŸã³ã«TTLã‚’å»¶é•·
            self.redis.setex(
                f"session:{session_id}",
                self.idle_timeout,  # æœ€å¾Œã®ã‚¢ã‚¯ã‚»ã‚¹ã‹ã‚‰30åˆ†
                json.dumps(data)
            )
            
            return data
        return None
```

**3. ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æœŸé™ï¼ˆçµ„ã¿åˆã‚ã›ï¼‰**
```python
class HybridTimeoutSession:
    def __init__(self, absolute_limit=28800, idle_timeout=1800):
        self.absolute_limit = absolute_limit  # 8æ™‚é–“
        self.idle_timeout = idle_timeout      # 30åˆ†
    
    def access_session(self, session_id):
        session_data = self.redis.get(f"session:{session_id}")
        
        if session_data:
            data = json.loads(session_data)
            created_at = datetime.fromisoformat(data['created_at'])
            
            # çµ¶å¯¾æœŸé™ãƒã‚§ãƒƒã‚¯
            if datetime.utcnow() - created_at > timedelta(seconds=self.absolute_limit):
                self.redis.delete(f"session:{session_id}")
                return None
            
            # ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°æœŸé™ã®æ›´æ–°
            data['last_accessed'] = datetime.utcnow().isoformat()
            remaining_time = min(
                self.idle_timeout,
                self.absolute_limit - int((datetime.utcnow() - created_at).total_seconds())
            )
            
            self.redis.setex(
                f"session:{session_id}",
                remaining_time,
                json.dumps(data)
            )
            
            return data
        return None
```

### æ¥­ç•Œåˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé–“ã®è¨­è¨ˆæŒ‡é‡

| æ¥­ç•Œãƒ»ç”¨é€” | çµ¶å¯¾æœŸé™ | ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°æœŸé™ | ç†ç”± |
|-----------|---------|-------------------|------|
| **é‡‘èãƒ»æ±ºæ¸ˆ** | 15-30åˆ† | 5-10åˆ† | é«˜ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦æ±‚ |
| **åŒ»ç™‚ãƒ»å€‹äººæƒ…å ±** | 30-60åˆ† | 15åˆ† | ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­· |
| **ä¸€èˆ¬ECã‚µã‚¤ãƒˆ** | 24æ™‚é–“ | 30åˆ† | åˆ©ä¾¿æ€§ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ |
| **ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ»æƒ…å ±** | 7æ—¥ | 1æ™‚é–“ | ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£é‡è¦– |
| **ã‚²ãƒ¼ãƒ ãƒ»ã‚¨ãƒ³ã‚¿ãƒ¡** | 30æ—¥ | 2æ™‚é–“ | ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“é‡è¦– |

## åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã§ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

### ã‚»ãƒƒã‚·ãƒ§ãƒ³å…±æœ‰æˆ¦ç•¥

**1. å…±æœ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆRedis Clusterï¼‰**
```python
import redis.sentinel

class DistributedSessionManager:
    def __init__(self):
        # Redis Sentinelã‚’ä½¿ç”¨ã—ãŸé«˜å¯ç”¨æ€§æ§‹æˆ
        sentinel = redis.sentinel.Sentinel([
            ('redis-sentinel-1', 26379),
            ('redis-sentinel-2', 26379),
            ('redis-sentinel-3', 26379)
        ])
        
        # ãƒã‚¹ã‚¿ãƒ¼ãƒ»ã‚¹ãƒ¬ãƒ¼ãƒ–æ§‹æˆ
        self.master = sentinel.master_for('mymaster', socket_timeout=0.1)
        self.slave = sentinel.slave_for('mymaster', socket_timeout=0.1)
    
    def write_session(self, session_id, data):
        """ãƒã‚¹ã‚¿ãƒ¼ã«æ›¸ãè¾¼ã¿"""
        return self.master.setex(f"session:{session_id}", 3600, json.dumps(data))
    
    def read_session(self, session_id):
        """ã‚¹ãƒ¬ãƒ¼ãƒ–ã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰"""
        try:
            data = self.slave.get(f"session:{session_id}")
            return json.loads(data) if data else None
        except:
            # ã‚¹ãƒ¬ãƒ¼ãƒ–éšœå®³æ™‚ã¯ãƒã‚¹ã‚¿ãƒ¼ã‹ã‚‰èª­ã¿è¾¼ã¿
            data = self.master.get(f"session:{session_id}")
            return json.loads(data) if data else None
```

**2. ã‚»ãƒƒã‚·ãƒ§ãƒ³è¤‡è£½ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆMulti-Regionï¼‰**
```python
class MultiRegionSessionManager:
    def __init__(self):
        self.primary_redis = redis.Redis(host='redis-us-east')
        self.backup_redis = redis.Redis(host='redis-eu-west')
        self.local_cache = {}
    
    def replicated_write(self, session_id, data):
        """è¤‡æ•°ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®è¤‡è£½æ›¸ãè¾¼ã¿"""
        json_data = json.dumps(data)
        
        # ãƒ—ãƒ©ã‚¤ãƒãƒªãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®æ›¸ãè¾¼ã¿
        try:
            self.primary_redis.setex(f"session:{session_id}", 3600, json_data)
        except redis.ConnectionError:
            pass
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®éåŒæœŸè¤‡è£½
        try:
            self.backup_redis.setex(f"session:{session_id}", 3600, json_data)
        except redis.ConnectionError:
            pass
        
        # ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚æ›´æ–°
        self.local_cache[session_id] = data
    
    def resilient_read(self, session_id):
        """éšœå®³è€æ€§ã®ã‚ã‚‹èª­ã¿è¾¼ã¿"""
        # L1: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        if session_id in self.local_cache:
            return self.local_cache[session_id]
        
        # L2: ãƒ—ãƒ©ã‚¤ãƒãƒªãƒªãƒ¼ã‚¸ãƒ§ãƒ³
        try:
            data = self.primary_redis.get(f"session:{session_id}")
            if data:
                parsed_data = json.loads(data)
                self.local_cache[session_id] = parsed_data
                return parsed_data
        except redis.ConnectionError:
            pass
        
        # L3: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒªãƒ¼ã‚¸ãƒ§ãƒ³
        try:
            data = self.backup_redis.get(f"session:{session_id}")
            if data:
                return json.loads(data)
        except redis.ConnectionError:
            pass
        
        return None
```

## ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

### ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šæ”»æ’ƒï¼ˆSession Fixationï¼‰å¯¾ç­–

```python
class SecureSessionManager:
    def login_user(self, user_id, current_session_id=None):
        """ãƒ­ã‚°ã‚¤ãƒ³æ™‚ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³å†ç”Ÿæˆ"""
        
        # æ—¢å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ç„¡åŠ¹åŒ–
        if current_session_id:
            self.destroy_session(current_session_id)
        
        # æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆ
        new_session_id = self.generate_secure_session_id()
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        session_data = {
            'user_id': user_id,
            'authenticated': True,
            'login_time': datetime.utcnow().isoformat(),
            'ip_address': self.get_client_ip(),
            'user_agent': self.get_user_agent()
        }
        
        self.redis.setex(
            f"session:{new_session_id}",
            self.session_timeout,
            json.dumps(session_data)
        )
        
        return new_session_id
    
    def generate_secure_session_id(self):
        """æš—å·è«–çš„ã«å®‰å…¨ãªã‚»ãƒƒã‚·ãƒ§ãƒ³IDç”Ÿæˆ"""
        import secrets
        return secrets.token_urlsafe(32)  # 256ãƒ“ãƒƒãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ å€¤
    
    def validate_session_context(self, session_id, request):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ¤œè¨¼"""
        session_data = self.get_session(session_id)
        
        if not session_data:
            return False
        
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ¤œè¨¼ï¼ˆç’°å¢ƒã«ã‚ˆã£ã¦ã¯ç„¡åŠ¹åŒ–ï¼‰
        if session_data.get('ip_address') != self.get_client_ip():
            self.destroy_session(session_id)
            return False
        
        # User-Agentã®æ¤œè¨¼
        if session_data.get('user_agent') != self.get_user_agent():
            self.destroy_session(session_id)
            return False
        
        return True
```

### ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒã‚¤ã‚¸ãƒ£ãƒƒã‚¯å¯¾ç­–

```python
class AntiHijackingSessionManager:
    def __init__(self):
        self.suspicious_threshold = 5  # ç–‘ã‚ã—ã„ã‚¢ã‚¯ã‚»ã‚¹é–¾å€¤
    
    def track_session_access(self, session_id, request):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¿½è·¡"""
        access_key = f"access_log:{session_id}"
        
        access_info = {
            'timestamp': datetime.utcnow().isoformat(),
            'ip_address': self.get_client_ip(),
            'user_agent': self.get_user_agent(),
            'location': self.get_geolocation()
        }
        
        # ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ 
        self.redis.lpush(access_key, json.dumps(access_info))
        self.redis.ltrim(access_key, 0, 10)  # æœ€æ–°10ä»¶ã®ã¿ä¿æŒ
        self.redis.expire(access_key, 3600)
        
        # ç•°å¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
        if self.detect_suspicious_activity(session_id):
            self.force_logout_all_sessions(session_id)
            return False
        
        return True
    
    def detect_suspicious_activity(self, session_id):
        """ç–‘ã‚ã—ã„ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®æ¤œå‡º"""
        access_key = f"access_log:{session_id}"
        access_logs = self.redis.lrange(access_key, 0, -1)
        
        if len(access_logs) < 2:
            return False
        
        locations = []
        for log_entry in access_logs:
            data = json.loads(log_entry)
            locations.append(data.get('location', {}))
        
        # åœ°ç†çš„ã«é›¢ã‚ŒãŸå ´æ‰€ã‹ã‚‰ã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹æ¤œå‡º
        for i in range(len(locations) - 1):
            if self.calculate_distance(locations[i], locations[i+1]) > 1000:  # 1000km
                time_diff = self.calculate_time_difference(access_logs[i], access_logs[i+1])
                if time_diff < 3600:  # 1æ™‚é–“ä»¥å†…
                    return True
        
        return False
    
    def force_logout_all_sessions(self, user_id):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å¼·åˆ¶ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ"""
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’å–å¾—
        user_sessions_key = f"user_sessions:{user_id}"
        session_ids = self.redis.smembers(user_sessions_key)
        
        # å…¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
        for session_id in session_ids:
            self.destroy_session(session_id.decode())
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸€è¦§ã‚‚ã‚¯ãƒªã‚¢
        self.redis.delete(user_sessions_key)
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

### ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ

| ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ–¹å¼ | èª­ã¿å–ã‚Šé€Ÿåº¦ | æ›¸ãè¾¼ã¿é€Ÿåº¦ | ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ | æ°¸ç¶šåŒ– | ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ |
|---------------|-------------|-------------|-------------|-------|-----------------|
| **ãƒ¡ãƒ¢ãƒª** | 0.01ms | 0.01ms | é«˜ | ãªã— | ä½ |
| **Redis** | 0.1-1ms | 0.1-1ms | ä¸­ | ã‚ã‚Š | é«˜ |
| **Database** | 10-50ms | 10-50ms | ä½ | ã‚ã‚Š | ä¸­ |
| **ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ** | 5-20ms | 5-20ms | ä½ | ã‚ã‚Š | ä½ |

### ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ç›£è¦–

```python
import time
import psutil
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class SessionMetrics:
    active_sessions: int
    session_creation_rate: float
    session_destruction_rate: float
    average_session_duration: float
    redis_memory_usage: float
    cache_hit_ratio: float

class SessionPerformanceMonitor:
    def __init__(self):
        self.metrics_history: List[SessionMetrics] = []
        self.start_time = time.time()
        
    def collect_metrics(self) -> SessionMetrics:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³é–¢é€£ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†"""
        # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³æ•°
        active_sessions = self.redis.dbsize()
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆãƒ»å‰Šé™¤ãƒ¬ãƒ¼ãƒˆï¼ˆ1åˆ†é–“ã‚ãŸã‚Šï¼‰
        creation_rate = self.get_session_creation_rate()
        destruction_rate = self.get_session_destruction_rate()
        
        # å¹³å‡ã‚»ãƒƒã‚·ãƒ§ãƒ³æŒç¶šæ™‚é–“
        avg_duration = self.calculate_average_session_duration()
        
        # Redisãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
        redis_info = self.redis.info('memory')
        memory_usage = redis_info['used_memory'] / (1024 * 1024)  # MB
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡
        cache_hit_ratio = self.calculate_cache_hit_ratio()
        
        metrics = SessionMetrics(
            active_sessions=active_sessions,
            session_creation_rate=creation_rate,
            session_destruction_rate=destruction_rate,
            average_session_duration=avg_duration,
            redis_memory_usage=memory_usage,
            cache_hit_ratio=cache_hit_ratio
        )
        
        self.metrics_history.append(metrics)
        return metrics
    
    def detect_performance_issues(self, metrics: SessionMetrics) -> List[str]:
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œã®æ¤œå‡º"""
        issues = []
        
        # ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯
        if metrics.redis_memory_usage > 1024:  # 1GB
            issues.append("Redis memory usage exceeds 1GB")
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ãƒã‚§ãƒƒã‚¯
        if metrics.cache_hit_ratio < 0.95:  # 95%æœªæº€
            issues.append(f"Low cache hit ratio: {metrics.cache_hit_ratio:.2%}")
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆãƒ¬ãƒ¼ãƒˆã®æ€¥å¢—ãƒã‚§ãƒƒã‚¯
        if len(self.metrics_history) > 1:
            prev_rate = self.metrics_history[-2].session_creation_rate
            if metrics.session_creation_rate > prev_rate * 2:
                issues.append("Session creation rate doubled")
        
        return issues

class SessionLoadBalancer:
    """ã‚»ãƒƒã‚·ãƒ§ãƒ³è² è·åˆ†æ•£ç®¡ç†"""
    
    def __init__(self, redis_clusters: List[str]):
        self.clusters = {}
        for i, cluster in enumerate(redis_clusters):
            self.clusters[i] = redis.Redis.from_url(cluster)
    
    def get_cluster_for_session(self, session_id: str) -> redis.Redis:
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã«åŸºã¥ãã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼é¸æŠ"""
        # ä¸€è²«æ€§ã®ã‚ã‚‹ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        hash_value = hash(session_id) % len(self.clusters)
        return self.clusters[hash_value]
    
    def migrate_sessions(self, from_cluster: int, to_cluster: int):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å‹•çš„ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        source = self.clusters[from_cluster]
        target = self.clusters[to_cluster]
        
        # å…¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚­ãƒ¼ã‚’å–å¾—
        session_keys = source.keys("session:*")
        
        for key in session_keys:
            # ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            data = source.get(key)
            ttl = source.ttl(key)
            
            # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ã«ç§»è¡Œ
            if ttl > 0:
                target.setex(key, ttl, data)
            else:
                target.set(key, data)
            
            # ã‚½ãƒ¼ã‚¹ã‹ã‚‰å‰Šé™¤
            source.delete(key)
```

## é«˜åº¦ãªã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ç’°å¢ƒã§ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

```python
class MicroserviceSessionManager:
    """ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³å…±æœ‰"""
    
    def __init__(self):
        self.session_gateway = redis.Redis(host='session-gateway')
        self.service_caches = {}
    
    def create_federated_session(self, user_id: str, services: List[str]):
        """è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹é–“ã§å…±æœ‰ã™ã‚‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ"""
        master_session_id = self.generate_session_id()
        
        # ãƒã‚¹ã‚¿ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ
        master_session = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'authorized_services': services,
            'service_tokens': {}
        }
        
        # å„ã‚µãƒ¼ãƒ“ã‚¹ç”¨ã®ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
        for service in services:
            service_token = self.generate_service_token(master_session_id, service)
            master_session['service_tokens'][service] = service_token
        
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ã«ä¿å­˜
        self.session_gateway.setex(
            f"master_session:{master_session_id}",
            7200,  # 2æ™‚é–“
            json.dumps(master_session)
        )
        
        return master_session_id, master_session['service_tokens']
    
    def validate_service_access(self, service_token: str, service_name: str):
        """ã‚µãƒ¼ãƒ“ã‚¹å›ºæœ‰ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼"""
        # ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º
        token_data = self.decode_service_token(service_token)
        
        if not token_data:
            return None
        
        master_session_id = token_data['master_session_id']
        service = token_data['service']
        
        # ãƒã‚¹ã‚¿ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—
        master_session = self.session_gateway.get(f"master_session:{master_session_id}")
        
        if not master_session:
            return None
        
        session_data = json.loads(master_session)
        
        # ã‚µãƒ¼ãƒ“ã‚¹èªå¯ãƒã‚§ãƒƒã‚¯
        if service not in session_data['authorized_services']:
            return None
        
        # ã‚µãƒ¼ãƒ“ã‚¹ç”¨ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
        local_cache_key = f"{service}:{master_session_id}"
        self.service_caches[local_cache_key] = {
            'user_id': session_data['user_id'],
            'cached_at': datetime.utcnow().isoformat()
        }
        
        return session_data['user_id']

class StatelessSessionHandler:
    """å®Œå…¨ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†"""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.max_token_age = 3600
    
    def create_stateless_token(self, user_data: Dict) -> str:
        """ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ"""
        payload = {
            'user_data': user_data,
            'issued_at': time.time(),
            'expires_at': time.time() + self.max_token_age
        }
        
        # JWTãƒ©ã‚¤ã‚¯ãªãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
        header = {'alg': 'HS256', 'typ': 'JWT'}
        
        # Base64URL ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        header_encoded = self.base64url_encode(json.dumps(header))
        payload_encoded = self.base64url_encode(json.dumps(payload))
        
        # HMACç½²å
        message = f"{header_encoded}.{payload_encoded}"
        signature = hmac.new(
            self.secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).digest()
        signature_encoded = self.base64url_encode(signature)
        
        return f"{message}.{signature_encoded}"
    
    def validate_stateless_token(self, token: str) -> Dict:
        """ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼"""
        try:
            parts = token.split('.')
            if len(parts) != 3:
                return None
            
            header_encoded, payload_encoded, signature_encoded = parts
            
            # ç½²åæ¤œè¨¼
            message = f"{header_encoded}.{payload_encoded}"
            expected_signature = hmac.new(
                self.secret_key.encode(),
                message.encode(),
                hashlib.sha256
            ).digest()
            
            actual_signature = self.base64url_decode(signature_encoded)
            
            if not hmac.compare_digest(expected_signature, actual_signature):
                return None
            
            # ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å¾©å·
            payload = json.loads(self.base64url_decode(payload_encoded))
            
            # æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
            if time.time() > payload['expires_at']:
                return None
            
            return payload['user_data']
            
        except (ValueError, json.JSONDecodeError):
            return None
```

## ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­è¨ˆã®é¸æŠæŒ‡é‡

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ¥æ¨å¥¨æ§‹æˆ

```mermaid
flowchart TD
    A["è¦ä»¶åˆ†æ"] --> B{"ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‘ã‚¿ãƒ¼ãƒ³"}
    
    B -->|ãƒ¢ãƒãƒªã‚¹| C["ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³<br/>+ Redis"]
    B -->|ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹| D["ãƒ•ã‚§ãƒ‡ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³<br/>+ JWT"]
    B -->|ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹| E["ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³<br/>+ JWE"]
    B -->|ã‚¨ãƒƒã‚¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°| F["åˆ†æ•£ã‚»ãƒƒã‚·ãƒ§ãƒ³<br/>+ åœ°ç†çš„è¤‡è£½"]
    
    C --> G["é«˜ã„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£<br/>å¼·åˆ¶ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå¯èƒ½"]
    D --> H["ã‚µãƒ¼ãƒ“ã‚¹é–“ç‹¬ç«‹<br/>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«"]
    E --> I["ã‚¤ãƒ³ãƒ•ãƒ©ãƒ¬ã‚¹<br/>ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆå¯¾å¿œ"]
    F --> J["ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·<br/>ã‚°ãƒ­ãƒ¼ãƒãƒ«å¯¾å¿œ"]
```

### ã‚»ãƒƒã‚·ãƒ§ãƒ³æˆ¦ç•¥ã®æ±ºå®šãƒãƒˆãƒªãƒƒã‚¯ã‚¹

| è¦ä»¶ | ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ | Cookieãƒ™ãƒ¼ã‚¹ | JWT/ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ | ãƒ•ã‚§ãƒ‡ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰ |
|------|---------------|-------------|-----------------|-----------------|
| **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‡è¦–** | âœ… æœ€é© | âš ï¸ æ³¨æ„ | âš ï¸ æ³¨æ„ | âœ… è‰¯ã„ |
| **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£** | âš ï¸ åˆ¶é™ã‚ã‚Š | âœ… å„ªç§€ | âœ… å„ªç§€ | âœ… å„ªç§€ |
| **ã‚¤ãƒ³ãƒ•ãƒ©ã‚·ãƒ³ãƒ—ãƒ«æ€§** | âŒ è¤‡é›‘ | âœ… ã‚·ãƒ³ãƒ—ãƒ« | âœ… ã‚·ãƒ³ãƒ—ãƒ« | âŒ è¤‡é›‘ |
| **å¼·åˆ¶ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ** | âœ… å¯èƒ½ | âŒ å›°é›£ | âŒ å›°é›£ | âœ… å¯èƒ½ |
| **ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œ** | âŒ ä¸å¯ | âœ… éƒ¨åˆ†çš„ | âœ… éƒ¨åˆ†çš„ | âŒ ä¸å¯ |
| **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹** | âš ï¸ èª²é¡Œã‚ã‚Š | âš ï¸ èª²é¡Œã‚ã‚Š | âœ… é©ã—ã¦ã„ã‚‹ | âœ… æœ€é© |

## ã¾ã¨ã‚

**ç¾ä»£çš„ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®é‡è¦åŸå‰‡ï¼š**

1. **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£é©åˆæ€§**: ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆã«æœ€é©åŒ–ã•ã‚ŒãŸã‚»ãƒƒã‚·ãƒ§ãƒ³æˆ¦ç•¥ã®é¸æŠ
2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ**: ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šã€ãƒã‚¤ã‚¸ãƒ£ãƒƒã‚¯å¯¾ç­–ã®ç¢ºå®Ÿãªå®Ÿè£…
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: é©åˆ‡ãªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸é¸æŠã¨è² è·åˆ†æ•£è¨­è¨ˆ
4. **ç›£è¦–ãƒ»é‹ç”¨æ€§**: ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œã®æ—©æœŸæ¤œå‡º

**æŠ€è¡“é¸æŠã®è©•ä¾¡åŸºæº–ï¼š**
- **ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã‚»ãƒƒã‚·ãƒ§ãƒ³**: é«˜ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€å¼·åˆ¶åˆ¶å¾¡ãŒå¿…è¦ãªã‚·ã‚¹ãƒ†ãƒ 
- **Cookieãƒ™ãƒ¼ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³**: ã‚·ãƒ³ãƒ—ãƒ«ãªæ§‹æˆã€ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹å¿—å‘ã®ã‚·ã‚¹ãƒ†ãƒ 
- **JWT/ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹**: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã€ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ç’°å¢ƒ
- **ãƒ•ã‚§ãƒ‡ãƒ¬ãƒ¼ãƒ†ãƒƒãƒ‰**: è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã®çµ±åˆèªè¨¼ãŒå¿…è¦ãªã‚·ã‚¹ãƒ†ãƒ 

**é‹ç”¨ã«ãŠã‘ã‚‹æˆåŠŸè¦å› ï¼š**
- ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰åŠ¹æœŸé–“ã®æ¥­ç•Œãƒ»ç”¨é€”åˆ¥æœ€é©åŒ–
- åˆ†æ•£ç’°å¢ƒã§ã®å¯ç”¨æ€§ãƒ»ä¸€è²«æ€§ã®æ‹…ä¿
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨è‡ªå‹•çš„ãªç•°å¸¸æ¤œçŸ¥
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã¸ã®è¿…é€Ÿãªå¯¾å¿œä½“åˆ¶

é©åˆ‡ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã¨ã‚·ã‚¹ãƒ†ãƒ å®‰å…¨æ€§ã‚’ä¸¡ç«‹ã—ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ã§é‹ç”¨åŠ¹ç‡ã®é«˜ã„Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚
